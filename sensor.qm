<?xml version="1.0" encoding="UTF-8"?>
<model version="4.0.3" links="0">
 <framework name="qpn"/>
 <package name="AOs" stereotype="0x02">
  <class name="Sensor" superclass="qpn::QActive">
   <statechart>
    <initial target="../2">
     <initial_glyph conn="46,7,5,0,34,17">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <entry brief="Activate peripheral power">#ifdef TRACE
  Serial.println(&quot;Enter Active&quot;);
#endif

BSP_ActivatePeripherals();

</entry>
     <exit>#ifdef TRACE
    Serial.println(&quot;Exit Active&quot;);
#endif</exit>
     <initial target="../4">
      <initial_glyph conn="21,22,5,0,14,3">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <tran trig="SLEEP" target="../../2">
      <tran_glyph conn="54,32,1,3,14">
       <action box="5,-3,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="SEND_DATA" target="../5">
      <tran_glyph conn="9,42,3,3,13">
       <action box="1,-3,12,2"/>
      </tran_glyph>
     </tran>
     <tran trig="EMISSION_FINISHED">
      <action>QACTIVE_POST(&amp;me-&gt;super, SLEEP_SIG, me-&gt;super.prio);</action>
      <tran_glyph conn="9,54,3,-1,26">
       <action box="2,-3,17,2"/>
      </tran_glyph>
     </tran>
     <state name="TempSensing">
      <entry brief="Setup sensing">#ifdef TRACE
  Serial.println(F(&quot;Enter TempSensing&quot;));
#endif

// http://www.ti.com/lit/ds/symlink/lm35.pdf p.12 
// (startup response)
_delay_ms(30);

double sensorVoltage = 0;
double refVoltage = 0;

int sample = 0;

long vcc = BSP_readVcc();

// first read is usually false 
// make a blank read
sample = BSP_analogReadLM35();

for (uint8_t j = 0 ; j &lt; TEMP_SAMPLE_COUNT ; ++j)
{
  sample = BSP_analogReadLM35();
  sensorVoltage = sensorVoltage + sample;
}
sensorVoltage = sensorVoltage / TEMP_SAMPLE_COUNT;

sample = BSP_analogReadRef();
for (uint8_t j = 0 ; j &lt; TEMP_SAMPLE_COUNT ; ++j)
{
  sample = BSP_analogReadRef();
  refVoltage = refVoltage + sample;
}
refVoltage = refVoltage / TEMP_SAMPLE_COUNT;


float temperature_celcius = (sensorVoltage - refVoltage) * ( (vcc/10) / 1023.0);

bool isNegative = (temperature_celcius &lt; 0);

temperature_celcius = abs(temperature_celcius);
int i_temp = round(temperature_celcius*10); // temp is int plus one decimal (ie raw 263.90 =&gt; 264)
uint8_t integer = i_temp/10; // ie 26 in this sample
uint8_t fractional = i_temp % 10; // ie 4 in this sample

BSP_StoreTempData(isNegative, integer, fractional);

QACTIVE_POST(&amp;me-&gt;super, SEND_DATA_SIG, me-&gt;super.prio);</entry>
      <exit>#ifdef TRACE
    Serial.println(F(&quot;Exit TempSensing&quot;));
#endif
</exit>
      <state_glyph node="26,25,27,6">
       <entry box="1,2,23,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="Emitting">
      <entry brief="Transmit all sensors information">#ifdef TRACE
    Serial.println(F(&quot;Enter Emitting&quot;));
#endif

BSP_SendData433();

QACTIVE_POST(&amp;me-&gt;super, EMISSION_FINISHED_SIG, me-&gt;super.prio);</entry>
      <exit>// not needed in transmit mode
// QACTIVE_POST(AO_Timer, QP_CLOCK, AO_Timer.prio);

#ifdef TRACE
    Serial.println(F(&quot;Exit Emitting&quot;));
#endif</exit>
      <state_glyph node="22,38,30,11">
       <entry box="1,2,26,3"/>
       <exit box="1,5,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="9,16,45,47">
      <entry box="1,2,22,2"/>
      <exit box="1,4,6,3"/>
     </state_glyph>
    </state>
    <state name="Sleeping">
     <entry brief="Cut peripherals power">#ifdef TRACE
    Serial.println(&quot;Enter Sleeping&quot;);
#endif

BSP_DeactivatePeripherals();

QActive_armX(&amp;me-&gt;super, 0U, BSP_TICKS_PER_SEC*5U, 0U);</entry>
     <exit>#ifdef TRACE
    Serial.println(&quot;Exit Sleeping&quot;);
#endif
QActive_disarmX(&amp;me-&gt;super, 0U);
</exit>
     <tran trig="Q_TIMEOUT" target="../../1">
      <tran_glyph conn="68,37,3,1,-14">
       <action box="-11,-3,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="68,24,24,16">
      <entry box="1,2,20,2"/>
      <exit box="1,4,22,2"/>
     </state_glyph>
    </state>
    <state_diagram size="147,82"/>
   </statechart>
  </class>
 </package>
 <directory name=".">
  <directory name="src">
   <file name="Sensor.cpp" codec="UTF-8">
    <text>/*****************************************************************************
* Model: sensor.qm
* File:  ./SensorV2.cpp
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::SensorV2.cpp} .......................................................*/
#include &quot;SensorV2_API.h&quot;        // Hardware interface
#include &quot;qpn.h&quot;        // QP-nano framework
#include &lt;util/delay.h&gt;

Q_DEFINE_THIS_MODULE(&quot;sensor&quot;)

#ifdef __AVR_ATtiny24A__
#include &quot;BSPs/ATTiny24a_bsp.h&quot;
#endif


// define to println() many information
#define TRACE 1

const uint8_t TEMP_SAMPLE_COUNT = 10;


//============================================================================
enum SensorSignals {
    SEND_DATA_SIG = Q_USER_SIG,
    EMISSION_FINISHED_SIG,
    SLEEP_SIG,
    WAKEUP_SIG,

};


#if ((QP_VERSION &lt; 591) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpn version 5.9.1 or higher required
#endif

/*${AOs::Sensor} ...........................................................*/
typedef struct Sensor {
/* protected: */
    QActive super;
} Sensor;

/* protected: */
static QState Sensor_initial(Sensor * const me);
static QState Sensor_Active(Sensor * const me);
static QState Sensor_TempSensing(Sensor * const me);
static QState Sensor_Emitting(Sensor * const me);
static QState Sensor_Sleeping(Sensor * const me);

/*${AOs::Sensor} ...........................................................*/
/*${AOs::Sensor::SM} .......................................................*/
static QState Sensor_initial(Sensor * const me) {
    /* ${AOs::Sensor::SM::initial} */
    return Q_TRAN(&amp;Sensor_Sleeping);
}
/*${AOs::Sensor::SM::Active} ...............................................*/
static QState Sensor_Active(Sensor * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sensor::SM::Active} */
        case Q_ENTRY_SIG: {
            #ifdef TRACE
              Serial.println(&quot;Enter Active&quot;);
            #endif

            BSP.ActivatePeripherals();


            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sensor::SM::Active} */
        case Q_EXIT_SIG: {
            #ifdef TRACE
                Serial.println(&quot;Exit Active&quot;);
            #endif
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sensor::SM::Active::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&amp;Sensor_TempSensing);
            break;
        }
        /* ${AOs::Sensor::SM::Active::SLEEP} */
        case SLEEP_SIG: {
            status_ = Q_TRAN(&amp;Sensor_Sleeping);
            break;
        }
        /* ${AOs::Sensor::SM::Active::SEND_DATA} */
        case SEND_DATA_SIG: {
            status_ = Q_TRAN(&amp;Sensor_Emitting);
            break;
        }
        /* ${AOs::Sensor::SM::Active::EMISSION_FINISHED} */
        case EMISSION_FINISHED_SIG: {
            QACTIVE_POST(&amp;me-&gt;super, SLEEP_SIG, me-&gt;super.prio);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&amp;QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Sensor::SM::Active::TempSensing} ..................................*/
static QState Sensor_TempSensing(Sensor * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sensor::SM::Active::TempSensing} */
        case Q_ENTRY_SIG: {
            #ifdef TRACE
              Serial.println(F(&quot;Enter TempSensing&quot;));
            #endif

            BSP.SenseTemp();
            BSP.SendData433();

            QACTIVE_POST(&amp;me-&gt;super, SEND_DATA_SIG, me-&gt;super.prio);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sensor::SM::Active::TempSensing} */
        case Q_EXIT_SIG: {
            #ifdef TRACE
                Serial.println(F(&quot;Exit TempSensing&quot;));
            #endif

            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&amp;Sensor_Active);
            break;
        }
    }
    return status_;
}
/*${AOs::Sensor::SM::Active::Emitting} .....................................*/
static QState Sensor_Emitting(Sensor * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sensor::SM::Active::Emitting} */
        case Q_ENTRY_SIG: {
            #ifdef TRACE
                Serial.println(F(&quot;Enter Emitting&quot;));
            #endif

            BSP.SendData433();

            QACTIVE_POST(&amp;me-&gt;super, EMISSION_FINISHED_SIG, me-&gt;super.prio);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sensor::SM::Active::Emitting} */
        case Q_EXIT_SIG: {
            // not needed in transmit mode
            // QACTIVE_POST(AO_Timer, QP_CLOCK, AO_Timer.prio);

            #ifdef TRACE
                Serial.println(F(&quot;Exit Emitting&quot;));
            #endif
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&amp;Sensor_Active);
            break;
        }
    }
    return status_;
}
/*${AOs::Sensor::SM::Sleeping} .............................................*/
static QState Sensor_Sleeping(Sensor * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sensor::SM::Sleeping} */
        case Q_ENTRY_SIG: {
            #ifdef TRACE
                Serial.println(&quot;Enter Sleeping&quot;);
            #endif

            BSP.DeactivatePeripherals();

            QActive_armX(&amp;me-&gt;super, 0U, BSP.TICKS_PER_SEC*5U, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sensor::SM::Sleeping} */
        case Q_EXIT_SIG: {
            #ifdef TRACE
                Serial.println(&quot;Exit Sleeping&quot;);
            #endif
            QActive_disarmX(&amp;me-&gt;super, 0U);

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sensor::SM::Sleeping::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&amp;Sensor_Active);
            break;
        }
        default: {
            status_ = Q_SUPER(&amp;QHsm_top);
            break;
        }
    }
    return status_;
}


Sensor AO_Sensor;

// QF_active[] array defines all active object control blocks ----------------
static QEvt l_sensorQSto[5]; // Event queue storage for Sensor

QActiveCB const Q_ROM QF_active[] = {
  { (QActive *)0,           (QEvt *)0,        0U                  },
  { (QActive *)&amp;AO_Sensor,  l_sensorQSto,     Q_DIM(l_sensorQSto) }
};


//............................................................................
//
int main() {

    BSP.Setup();

    BSP.PrintInfo();

    // initialize the QF-nano framework
    QF_init(Q_DIM(QF_active));
    QActive_ctor(&amp;AO_Sensor.super, Q_STATE_CAST(&amp;Sensor_initial));

    while(true)
    {
        QF_run(); // run the QP-nano application
    }
    return 0;
}

//============================================================================

// QF callbacks...
void QF_onStartup(void) {

#ifdef TRACE
    Serial.println(F(&quot;QF_onStartup&quot;));
#endif

    // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking...
    TCCR2A = (1U &lt;&lt; WGM21) | (0U &lt;&lt; WGM20);
    TCCR2B = (1U &lt;&lt; CS22 ) | (1U &lt;&lt; CS21) | (1U &lt;&lt; CS20); // 1/2^10
    ASSR  &amp;= ~(1U &lt;&lt; AS2);
    TIMSK2 = (1U &lt;&lt; OCIE2A); // enable TIMER2 compare Interrupt
    TCNT2  = 0U;

    // set the output-compare register based on the desired tick frequency
    OCR2A  = (F_CPU / BSP.TICKS_PER_SEC / 1024U) - 1U;
}

//............................................................................
void QV_onIdle(void) {   // called with interrupts DISABLED

#ifdef TRACE
    //Serial.println(F(&quot;QV_onIdle&quot;));
#endif

    // Put the CPU and peripherals to the low-power mode. You might
    // need to customize the clock management for your application,
    // see the datasheet for your particular AVR MCU.
    SMCR = (0 &lt;&lt; SM0) | (1 &lt;&lt; SE); // idle mode, adjust to your project
    QV_CPU_SLEEP();  // atomically go to sleep and enable interrupts
}

//............................................................................
void Q_onAssert(char const Q_ROM * const file, int line) {

#ifdef TRACE
    // implement the error-handling policy for your application!!!
    Serial.print(F(&quot;Assertion raised in '&quot;));
    Serial.print(file);
    Serial.print(F(&quot;' at line&quot;));
    Serial.print(line);
#endif
    QF_INT_DISABLE(); // disable all interrupts
    QF_RESET();  // reset the CPU
}
</text>
   </file>
  </directory>
 </directory>
</model>
